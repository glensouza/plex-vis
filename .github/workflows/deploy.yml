name: Deploy PlexVis Direct

permissions:
  contents: read

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
  workflow_dispatch:

# Ensure only the latest run for a given branch proceeds; cancel previous in-progress/queued runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PUBLISH_DIR: './publish'
  DEPLOY_DIR: '/opt/plex-vis'
  SERVICE_NAME: 'plexvis'

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      build_number: ${{ steps.set_build_number.outputs.build_number }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x

      - name: Set Build Number (daily counter)
        id: set_build_number
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BRANCH: ${{ github.ref_name }}
        run: |
          DATE=$(date +'%Y%m%d')
          echo "Counting workflow runs for date $DATE on branch ${BRANCH}..."

          # Query workflow runs (first 100). This uses the Actions API instead of releases.
          RUNS_JSON=$(curl -s -H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/runs?per_page=100&branch=${BRANCH}")

          # Extract created_at timestamps (ISO 8601) and count those matching today's date
          CREATED_ATS=$(echo "$RUNS_JSON" | grep -oP '"created_at"\s*:\s*"\K[^"]+' || true)

          COUNT=0
          if [ -n "$CREATED_ATS" ]; then
            COUNT=$(echo "$CREATED_ATS" | while read -r dt; do echo "${dt:0:10}"; done | tr -d '-' | grep -x "$DATE" | wc -l | tr -d ' ')
          fi

          NEXT=$((COUNT + 1))
          BUILD_NUMBER="${DATE}.${NEXT}"

          echo "Computed BUILD_NUMBER=$BUILD_NUMBER"
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: Restore dependencies
        run: dotnet restore PlexVis.Web/PlexVis.Web.csproj
      
      - name: Build application
        run: dotnet build PlexVis.Web/PlexVis.Web.csproj -c Release --no-restore

      - name: Publish application
        run: dotnet publish PlexVis.Web/PlexVis.Web.csproj -c Release -o ${{ env.PUBLISH_DIR }} --no-build

      - name: Create deployment archive
        run: |
          cd ${{ env.PUBLISH_DIR }}
          # create tar in repository root for easier reuse across steps
          tar -czf ../plexvis-${{ env.BUILD_NUMBER }}.tar.gz .
          cd ..
          sha256sum plexvis-${{ env.BUILD_NUMBER }}.tar.gz > plexvis-${{ env.BUILD_NUMBER }}.tar.gz.sha256

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: plexvis-build
          path: |
            plexvis-${{ env.BUILD_NUMBER }}.tar.gz
            plexvis-${{ env.BUILD_NUMBER }}.tar.gz.sha256
          retention-days: 30

      - name: Create deployment summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Number:** ${{ env.BUILD_NUMBER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ✅ Successful" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to Server
    needs: build
    runs-on: self-hosted
    environment: 
      name: production
      url: http://10.10.10.175:5000
    
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: plexvis-build

      - name: Set Build Number
        run: |
          echo "BUILD_NUMBER=${{ needs.build.outputs.build_number }}" >> $GITHUB_ENV
      
      - name: Verify artifact checksum
        run: |
          echo "Verifying deployment artifact integrity..."
          if sha256sum -c plexvis-${{ env.BUILD_NUMBER }}.tar.gz.sha256; then
            echo "✅ Checksum verified - artifact integrity confirmed"
          else
            echo "❌ Checksum verification failed - artifact may be corrupted"
            exit 1
          fi
      
      - name: Create backup of current deployment
        run: |
          if [ -d "${{ env.DEPLOY_DIR }}" ]; then
            BACKUP_DIR="/opt/backups/plexvis/deployments"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            
            # Create backup directory
            mkdir -p $BACKUP_DIR
            
            echo "Creating backup at $BACKUP_DIR/backup_$TIMESTAMP.tar.gz"
            
            # Create backup (pathfinder user runs the runner and owns the files)
            tar -czf $BACKUP_DIR/backup_$TIMESTAMP.tar.gz -C ${{ env.DEPLOY_DIR }} .
            
            # Keep only last 5 backups using find for safer sudo access
            OLD_BACKUPS=$(find $BACKUP_DIR -name 'backup_*.tar.gz' -type f -printf '%T@ %p\n' | sort -rn | tail -n +6 | cut -d' ' -f2-)
            if [ -n "$OLD_BACKUPS" ]; then
              echo "$OLD_BACKUPS" | while read backup_file; do
                rm -f "$backup_file"
              done
            fi
            
            echo "Backup created successfully"
          else
            echo "No existing deployment to backup"
          fi
      
      - name: Stop application service
        run: |
          echo "Stopping ${{ env.SERVICE_NAME }} service..."
          systemctl stop ${{ env.SERVICE_NAME }}
          echo "Service stopped successfully"
      
      - name: Deploy application
        run: |
          # Print ownership and permissions for deployment dir before deploy:
          ls -la ${{ env.DEPLOY_DIR }} || true

          echo "Deploying to ${{ env.DEPLOY_DIR }}..."
          mkdir -p ${{ env.DEPLOY_DIR }}
          
          # Extract new version
          tar -xzf plexvis-${{ env.BUILD_NUMBER }}.tar.gz -C ${{ env.DEPLOY_DIR }}

          echo "Deployment completed successfully"
      
      - name: Start application service
        run: |
          echo "Starting ${{ env.SERVICE_NAME }} service..."
          systemctl start ${{ env.SERVICE_NAME }}
          echo "Service start command executed"

          # Wait a short period for the service to become active
          sleep 5
        
          # Check if service is running
          if systemctl is-active --quiet ${{ env.SERVICE_NAME }}; then
              echo "Service started successfully"
          else
              echo "Service failed to start. Checking logs..."
              # TODO: HERE
              journalctl -u ${{ env.SERVICE_NAME }} -n50 --no-pager || true
              exit 1
          fi
      
      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # Wait for application to be ready
          for i in {1..30}; do
            if curl -f -s http://localhost:5000/alive > /dev/null 2>&1; then
              echo "Application is responding on /alive endpoint"
              break
            fi
            echo "Waiting for application to start... ($i/30)"
            sleep 2
          done
          
          # Final health check
          if curl -f -s http://localhost:5000/alive > /dev/null 2>&1; then
            echo "✅ Deployment verification successful"
            echo "Application is healthy and responding"
          else
            echo "❌ Deployment verification failed"
            echo "Application is not responding on health endpoint"
            journalctl -u ${{ env.SERVICE_NAME }} -n100 --no-pager || true
            exit 1
          fi

      - name: Create deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed to:** ${{ env.DEPLOY_DIR }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Service:** ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ✅ Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service Status" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
          systemctl status ${{ env.SERVICE_NAME }} --no-pager || true >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
      
      - name: Cleanup old artifacts
        if: always()
        run: |
          rm -f plexvis-*.tar.gz*
          echo "Cleaned up deployment artifacts"

  rollback:
    name: Rollback on Failure
    needs: deploy
    if: failure()
    runs-on: self-hosted
    permissions:
      contents: read
    
    steps:
      - name: Find latest backup
        id: find_backup
        run: |
          BACKUP_DIR="/opt/backups/plexvis/deployments"
          LATEST_BACKUP=$(ls -t $BACKUP_DIR/backup_*.tar.gz 2>/dev/null | head -n 1)
          if [ -n "$LATEST_BACKUP" ]; then
            echo "backup_file=$LATEST_BACKUP" >> $GITHUB_OUTPUT
            echo "Found backup: $LATEST_BACKUP"
          else
            echo "No backup found"
            exit 1
          fi
      
      - name: Restore from backup
        if: steps.find_backup.outputs.backup_file != ''
        run: |
          echo "Rolling back to backup: ${{ steps.find_backup.outputs.backup_file }}"
          
          # Stop service
          systemctl stop ${{ env.SERVICE_NAME }}
          
          # Restore backup
          tar -xzf ${{ steps.find_backup.outputs.backup_file }} -C ${{ env.DEPLOY_DIR }}
          
          # Start service
          systemctl start ${{ env.SERVICE_NAME }}

          echo "Rollback completed"
      
      - name: Verify rollback
        run: |
          sleep 5
          if systemctl is-active --quiet ${{ env.SERVICE_NAME }}; then
            echo "✅ Rollback successful - service is running"
          else
            echo "❌ Rollback failed - service is not running"
            journalctl -u ${{ env.SERVICE_NAME }} -n50 --no-pager
            exit 1
          fi

  notify:
    name: Send Notification
    needs: [build, deploy]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Create notification summary
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "status=✅ Deployment Successful" >> $GITHUB_ENV
            echo "color=success" >> $GITHUB_ENV
          else
            echo "status=❌ Deployment Failed" >> $GITHUB_ENV
            echo "color=danger" >> $GITHUB_ENV
          fi
      
      - name: Deployment result
        run: |
          echo "### ${{ env.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- Workflow: ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "- Run: ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
